package hai913i.tp2.spoon.visitors;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import hai913i.tp2.spoon.filters.FieldsWithGetterFilter;
import spoon.processing.AbstractProcessor;
import spoon.reflect.code.CtCodeSnippetStatement;
import spoon.reflect.code.CtComment;
import spoon.reflect.code.CtConstructorCall;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.Factory;

public class ToStringGenerator extends AbstractProcessor<CtClass> {
	
	private Map<CtClass, List<CtMethod>> map = new HashMap<>();
	
	
	public boolean isToBeProcessed(CtClass candidate) {
		return !analyze(candidate).isEmpty();
	}

	
	public void process(CtClass cls) {
		Factory factory = getFactory();
		
		CtMethod toStringMethod = factory.createMethod();
		toStringMethod.setVisibility(ModifierKind.PUBLIC);
		toStringMethod.setSimpleName("toString");
		toStringMethod.setType(factory.Type().stringType());
		
		CtAnnotation<Override> overrideAnnotation = factory.createAnnotation();
		overrideAnnotation.setAnnotationType(factory.Annotation().createReference(Override.class));
		toStringMethod.addAnnotation(overrideAnnotation);
		
		CtComment autoGeneratedComment = factory.createComment();
		autoGeneratedComment.setContent("Automatically generated by Spoon");
		toStringMethod.addComment(autoGeneratedComment);
		
		String toStringContent = toStringContent(cls);
		
		CtCodeSnippetStatement toStringStatement = factory
				.Code()
				.createCodeSnippetStatement(toStringContent);
		
		toStringMethod.setBody(toStringStatement);
		System.out.println("generated toString() for " + cls.getQualifiedName()+":");
		System.out.println(toStringMethod);
		
		cls.addMethod(toStringMethod);
	}
	
	public List<CtField> analyze(CtClass cls){
		List<CtField> fieldsWithGetters = new ArrayList<>();
		
		if (cls.getMethodsByName("toString").isEmpty() 
				|| hasToStringWithEmptyBody(cls)) {
			FieldsWithGetterFilter filter = new FieldsWithGetterFilter(cls);
			
			fieldsWithGetters = cls.getElements(filter);
			
			if (!fieldsWithGetters.isEmpty())
				map.put(cls, filter.getGetters());
		}
		
		return fieldsWithGetters;
	}
	
	private boolean hasToStringWithEmptyBody(CtClass cls) {
		boolean hasToStringWithEmptyBody = true;
		
		if (!cls.getMethodsByName("toString").isEmpty()) {
			CtMethod toStringMethod = (CtMethod) cls.getMethodsByName("toString").get(0);
			hasToStringWithEmptyBody = toStringMethod.getBody().getStatements().isEmpty();
		}
		
		return hasToStringWithEmptyBody;
	}
	
	private String toStringContent(CtClass cls) {
		StringBuilder builder = new StringBuilder();
		String attributeName = "";
		
		builder.append("java.lang.StringBuilder builder = new java.lang.StringBuilder();\n");
		
		for (CtMethod getter: map.get(cls)) {
			attributeName = FieldsWithGetterFilter
					.getGetterFieldName(getter.getSimpleName());
			
			builder.append("builder.append(\"" + attributeName + ": \");\n");
			builder.append("builder.append(" + getter.getSimpleName() + "()+\"\\n\");\n\n");
		}
		
		builder.append("return builder.toString()");
		
		return builder.toString();
	}
}
